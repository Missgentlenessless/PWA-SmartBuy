关于发表过程中的几个问题

1.关于缓存清除

首先，再提一遍。之前有memoryCache和diskCache，现在又多了个ServiceWorker cache，三者是分开存储的。    
另外这部分缓存我想应该是可以通过清除浏览器缓存清除掉的，只有indexedDB是持久化的，虽然我并没有在网上找到相关说明。    
用户首次访问Service Worker控制的网站或页面时，Service Worker会立刻被下载。    
之后至少每24小时它会被下载一次。它可能被更频繁地下载，不过每24小时一定会被下载一次，以避免不良脚本长时间生效。    

Service Worker总有需要更新的一天，随着版本迭代，某一天，我们需要把新版本的功能发布上线，此时需要淘汰掉旧的缓存，旧的Service Worker和Cache Storage如何淘汰呢？    

self.addEventListener('activate', function(event) {
  var cacheWhitelist = ['counterxing'];

  event.waitUntil(
    caches.keys().then(function(cacheNames) {
      return Promise.all(
        cacheNames.map(function(cacheName) {
          if (cacheWhitelist.indexOf(cacheName) === -1) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});


首先有一个白名单，白名单中的Cache是不被淘汰的。之后通过caches.keys()拿到所有的Cache Storage，把不在白名单中的Cache淘汰。    
淘汰使用caches.delete()方法。它接收cacheName作为参数，删除该cacheName所有缓存。
我们在activate而不是install的时候执行这个操作是因为如果我们在install的时候立马执行它，那么依然在运行的旧版本的数据就坏了。    

2.PWA相对于Web App，原生App的应用价值

首先说明一点，PWA实际就是Web App，所以应用价值上，其实就直接转化为了Web App与原生App的应用价值的问题。    
我认为这是取决于App的功能，用户市场的抢占，如果一个App它的本身功能决定了它的使用频率并不高，那么我觉得是没有必要做成原生App的，    
比如前段时间的个人所得税，我个人认为没有必要安装一个App，只为了一年填一次资料。    
这种情况狂下如果网站与App并存的话，那我绝对会选择网站。再比如闹钟，这种完全不需要访问网络的应用，又要怎么把它做成一个Web App呢？    
再者用户市场的抢占问题上，拿我自己举例，如果我平时用惯了淘宝，天猫，京东，那我就很可能不会去考虑再安一个唯品会，拼多多，    
哪怕可能拼多多上的商品，质量更好价格更低（这只是假设），那么这时候你有没有一个原生APP我并不关心。    
而PWA实际是对传统WebApp做了一些功能增强，它是一组新特性的集合，我们没有一定要添加PWA所有可以做的功能，而仅仅是各取所需。    
而要加上哪些新特性，也是WebApp功能上的实际需求来决定的。比如对于一个实时性要求非常高的网站，就完全没必要也不应该去缓存后台返回的数据。    
但一个传统的Web App，只要不是功能过于单一，我想应该都有升级为PWA的价值，来提高用户体验。    


而对于PWA，我后来重新思考了一番，认为是持有更加积极的态度的。    
如果再让我给PWA打分的话，从长远来看可能会打120分。我当时为什么只打了70到80分，是因为当时的考虑没有给PWA和原生应用一个相同的客观条件。    
所以后来再考虑，如果在能够实现同样功能，网络状况相同的前提下，我认为我更愿意去使用PWA，    
因为它不需要安装，不占空间，如果再加上存储空间完全够用的前提的话，我还是更愿意使用PWA，因为两者在条件相同的情况下各方面的表现上几乎没有差异。    
更何况PWA作为Web App会更容易传播，维护成本更低。    

再者要提一点的是，我在发表的App中删掉的一部分内容，关于现有手机App的分类（所以之后我会再添加上）。    
现在的手机App分为三类：原生APP，WebAPP，HybridApp。其中HybridApp是一种介于原生APP和WebAPP之间的一类，淘宝，携程就属于这一类的典型，    
实际上可以说就是UI WebView里面套了一个Web App，从而降低了开发成本，又获得了访问原生API的能力。这一点和PWA出现的价值很相似。所以我猜想将来HybridApp应该和PWA有一场较量。    


3.关于indexedDB

随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。    

现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过4KB，且每次请求都会发送回服务器；    
LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。    
所以，需要一种新的解决方案，这就是 IndexedDB 诞生的背景。    

通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。    
IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。    
就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。    
IndexedDB 具有以下特点。    
（1）键值对储存。 IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。    
对象仓库中，数据以"键值对"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。
（2）异步。 IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。
（3）支持事务。 IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
（4）同源限制。 IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。
（5）储存空间大。 IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。
（6）支持二进制储存。 IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。
由于 IndexedDB 本身的规范还在持续演进中，当前的 IndexedDB 的实现还是使用浏览器前缀。    
在规范更加稳定之前，浏览器厂商对于标准 IndexedDB API 可能都会有不同的实现。    
但是一旦大家对规范达成共识的话，厂商就会不带前缀标记地进行实现。    
实际上一些实现已经移除了浏览器前缀：IE 10，Firefox 16 和 Chrome 24。    
当使用前缀的时候，基于 Gecko 内核的浏览器使用 moz 前缀，基于 WebKit 内核的浏览器会使用 webkit 前缀。

3.关于VAPID协议
很遗憾，这部分还是没有找到有价值的参考

4.还有一些补充
https://www.w3ctech.com/topic/866
 
 
